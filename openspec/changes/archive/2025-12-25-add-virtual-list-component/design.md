## 上下文

虚拟滚动列表是一种常见的性能优化技术，用于渲染大量列表项而不导致性能问题。核心思想是：只渲染可视区域内的项目，而不是一次性渲染所有项目。

### 背景

- **现状**：当前 `List` 和 `GroupedList` 组件一次性渲染所有项目，在包含数千文件的目录中会导致性能问题
- **需求**：项目 `project.md` 明确要求"大目录快速加载（延迟加载、虚拟滚动）"
- **约束**：必须使用 GPUI 框架，不能依赖外部 UI 组件库
- **参考**：gpui-component 项目的 `virtual_list.rs` 提供了基于 GPUI 的虚拟滚动实现参考

### 技术挑战

1. **不同高度项目**：文件列表中不同类型的项目可能有不同高度（如带图标、多行文本等），需要支持非统一高度
2. **滚动性能**：需要在滚动时快速计算可见范围，避免每帧全量扫描
3. **GPUI 集成**：需要正确实现 GPUI 的 `Element` trait 生命周期，管理状态缓存
4. **API 一致性**：需要保持与现有 `List` 组件相似的 API，便于开发者迁移

## 目标 / 非目标

### 目标

- 实现基于 GPUI 的虚拟滚动列表组件，支持纵向滚动
- 支持不同高度的列表项，通过 `item_sizes` 参数配置
- 提供与现有 `List` 组件一致的构建器 API
- 仅渲染可视区域内的项目，实现 60fps 滚动性能
- 支持滚动到指定项、滚动句柄控制等高级功能
- 支持加载、错误、空状态的统一显示

### 非目标

- **不支持横向滚动**：首个版本仅支持纵向滚动，满足文件列表场景（未来可扩展）
- **不支持动态高度测量**：需要开发者提前计算项目高度，不支持自动测量和调整（参考实现也是如此）
- **不替换现有 List**：作为新增选项提供，不强制迁移现有代码
- **不支持分组虚拟滚动**：暂不实现 `GroupedVirtualList`，仅实现基础 `VirtualList`
- **不支持复杂交互**：如拖拽重排、多列布局等，保持简单和专注

## 决策

### 决策 1：参考 gpui-component 的 virtual_list 实现

**理由**：
- gpui-component 是成熟的 GPUI 组件库，其 `virtual_list.rs` 已经解决了 GPUI 集成的关键问题
- 该实现支持不同高度项目、横纵向滚动、滚动句柄等完整功能
- 复用其核心算法（累积高度计算、可见范围查找）可以避免重复造轮子
- 参考其 Element trait 实现可以确保与 GPUI 生命周期正确集成

**实施方式**：
1. 学习参考实现的核心算法：
   - `ItemSizeLayout` 状态结构设计（sizes、origins、content_size）
   - `request_layout` 阶段的预计算逻辑
   - `prepaint` 阶段的可见范围计算和项目定位
2. 简化为纵向滚动专用版本（首个版本）
3. 调整 API 以匹配现有 `List` 组件风格
4. 添加状态显示逻辑（loading、error、empty）

### 决策 2：项目高度通过 `Rc<Vec<Pixels>>` 传递

**理由**：
- 避免大量高度数据的克隆（可能包含数千项）
- 使用 `Rc` 共享所有权，轻量级传递
- 允许外部缓存高度计算结果，多次使用

**替代方案**：
- ❌ 直接传递 `Vec<Pixels>`：每次克隆开销大
- ❌ 使用 `&[Pixels]` 生命周期引用：在 GPUI 组件中管理生命周期复杂
- ✅ `Rc<Vec<Pixels>>`：最佳平衡，参考实现也采用此方案

### 决策 3：渲染回调签名为 `Fn(&T, usize, &Theme) -> AnyElement`

**理由**：
- 相比现有 `List` 的 `Fn(&T, &Theme)` 增加 `usize` 索引参数
- 索引参数对虚拟列表至关重要：
  - 实现斑马纹样式（奇偶行不同背景）
  - 支持选中状态（外部通过索引判断是否选中）
  - 支持懒加载逻辑（如显示项目序号）
- 虽然 API 不完全一致，但额外参数提供必要灵活性

### 决策 4：使用 `SmallVec<[AnyElement; 32]>` 存储可见项

**理由**：
- 大多数场景下可见项少于 32 个（如 1080p 屏幕，30px 行高，约 36 行可见）
- `SmallVec` 在小于阈值时使用栈分配，避免堆分配开销
- 超过阈值时自动降级为堆分配，保持灵活性
- 参考实现使用 `SmallVec<[AnyElement; 64]>`，我们选择 32 作为更保守的值

### 决策 5：预计算 origins 向量，优化可见范围查找

**理由**：
- 可见范围查找需要根据滚动偏移找到第一个和最后一个可见项
- 朴素算法需要每次滚动时累积计算所有前序项高度，O(n) 复杂度
- 预计算 `origins[i]`（第 i 项的起始 Y 坐标）后，仍需 O(n) 扫描，但避免重复累加
- 未来可优化为二分查找 O(log n)，但当前实现保持简单

**权衡**：
- 增加内存开销：需存储 `Vec<Pixels>` 的 origins（每项 4 字节）
- 对于 10,000 项列表，仅增加 ~40KB 内存，可接受

### 决策 6：暂不实现横向滚动

**理由**：
- 文件列表场景主要使用纵向滚动
- 横向滚动增加实现复杂度（需要支持轴切换逻辑）
- 参考实现支持横向，但需要 `Axis` 参数和额外逻辑分支
- 先实现纵向版本，验证架构可行性后再扩展

**迁移路径**：
- 保留轴无关的核心算法设计
- 未来添加 `axis: Axis` 字段和 `h_virtual_list` 构造函数
- 修改可见范围计算逻辑支持横向

### 决策 7：不支持自动高度测量和调整

**理由**：
- 自动测量需要先渲染项目、获取实际高度、调整布局，复杂且低效
- 参考实现也要求提前提供 `item_sizes`
- 对于文件列表，项目高度通常固定或可预测（如图标行高固定）
- 开发者可以根据项目类型预先计算高度

**开发者指南**：
- 对于统一高度列表：`Rc::new(vec![px(30.); items.len()])`
- 对于不同类型项：根据类型枚举计算高度
- 可以在外部缓存高度数据，多次使用

## 风险 / 权衡

### 风险 1：GPUI 框架 API 变化

**风险**：GPUI 仍在快速迭代，Element trait、滚动 API 可能变化
**缓解措施**：
- 紧密跟随 GPUI 版本更新
- 参考 gpui-component 项目的更新，保持同步
- 隔离 GPUI 依赖，便于未来适配

### 风险 2：不同高度项目的累积计算性能

**风险**：每次滚动需要扫描 origins 查找可见范围，大列表可能慢
**缓解措施**：
- 当前 O(n) 扫描对于万级列表仍可接受（现代 CPU 每秒可处理百万级简单操作）
- 预计算 origins 避免重复累加，已是优化
- 未来可实现二分查找优化到 O(log n)

### 风险 3：API 不完全一致导致迁移成本

**风险**：`render_item` 签名增加索引参数，现有代码不能直接迁移
**缓解措施**：
- 提供清晰的迁移文档，说明如何添加索引参数
- 大多数场景不使用索引，可以添加 `_index` 忽略参数
- 权衡：额外参数提供的灵活性大于迁移成本

### 权衡：内存 vs 性能

- **增加内存**：预计算 sizes、origins 向量，每项 ~8 字节
- **提升性能**：避免每帧重复计算，实现 60fps 滚动
- **结论**：对于 10,000 项列表，增加 ~80KB 内存，换取流畅体验，值得

### 权衡：功能完整性 vs 实现复杂度

- **不支持横向滚动**：减少实现复杂度，专注核心场景
- **不支持自动测量**：避免复杂的测量-调整循环，性能更好
- **不支持分组**：保持简单，`GroupedVirtualList` 可作为未来扩展
- **结论**：优先实现稳定的纵向虚拟列表，验证架构后再扩展

## 迁移计划

### 阶段 1：独立实现和测试（当前）

1. 在 `list` 模块创建 `virtual.rs`，与现有 `mod.rs`、`grouped.rs` 并列
2. 实现 `VirtualList` 和 `VirtualListScrollHandle`
3. 创建独立测试或示例，验证基础功能
4. 不修改现有 `List` 和 `GroupedList`，确保零破坏性

### 阶段 2：文档和集成

1. 添加完整的文档注释和使用示例
2. 在 `explorer-app` 中创建演示用法（可选）
3. 更新项目文档，说明何时使用 `List` vs `VirtualList`

### 阶段 3：实际应用（未来）

1. 在 `explorer-app` 的文件列表中尝试使用 `VirtualList`
2. 对比性能差异，收集反馈
3. 根据反馈优化实现或 API

### 回滚计划

- 如果 `VirtualList` 有严重问题，不影响现有代码，可以直接删除 `virtual.rs`
- 现有 `List` 和 `GroupedList` 保持不变，应用可继续使用
- 低风险设计，易于试验和回滚

## 待解决问题

### 问题 1：是否需要支持 `ListItem` 组件与虚拟列表集成？

**现状**：`ListItem` 提供统一的样式和交互（选中状态、hover、点击/双击）
**问题**：虚拟列表的 `render_item` 回调返回 `AnyElement`，开发者可以自由选择是否使用 `ListItem`
**待决定**：
- 是否提供 `VirtualList` 的默认项目渲染器，自动使用 `ListItem`？
- 还是完全由开发者在回调中决定？

**倾向**：由开发者决定，保持灵活性。文档中提供使用 `ListItem` 的示例即可。

### 问题 2：是否需要支持动态添加/删除项目？

**现状**：虚拟列表依赖 `item_sizes`，如果项目数量变化，需要重新计算
**问题**：实时文件监控可能导致目录内容变化（新增/删除文件）
**待决定**：
- 是否需要提供增量更新 API（如 `insert_item`、`remove_item`）？
- 还是要求开发者重新构建整个 `VirtualList`？

**倾向**：初版要求重新构建（更简单），未来根据需求添加增量 API。

### 问题 3：是否需要支持键盘导航？

**现状**：文件列表规范要求键盘导航（上下键、空格、Ctrl+A 等）
**问题**：虚拟列表需要感知键盘事件，可能需要焦点管理
**待决定**：
- 虚拟列表是否内置键盘导航支持？
- 还是由外部组件（如 FileList）监听键盘并调用 `scroll_to_item`？

**倾向**：由外部组件处理，虚拟列表仅提供 `scroll_to_item` 等控制 API。保持组件职责单一。

## 参考资料

- **GPUI 官方文档**：了解 Element trait、滚动 API、状态管理
- **gpui-component/virtual_list.rs**：核心算法和 GPUI 集成参考
  - 路径：`/Volumes/Data/Code/temp/gpui/gpui-component/crates/ui/src/virtual_list.rs`
- **项目 project.md**：性能要求和架构约定
- **现有 List 组件**：`crates/explorer-component/src/list/mod.rs`，API 一致性参考
