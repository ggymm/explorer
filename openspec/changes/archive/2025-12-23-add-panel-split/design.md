# 设计文档：主面板任意拆分功能

## 上下文

当前 Explorer 应用采用简单的左右两栏布局：左侧是固定的侧边栏（显示存储位置和快捷访问），右侧是单一的主面板（显示文件列表）。这种布局限制了用户同时查看多个目录的能力。

用户需求：
- 能够同时查看和操作多个目录
- 支持横向（左右）和纵向（上下）拆分
- 拆分后的每个面板可以继续拆分（任意深度的嵌套）
- 通过标题栏按钮方便地创建新面板

技术约束：
- 必须使用 GPUI 框架自行实现所有 UI 组件
- 需要保持 60fps 的流畅性能
- 遵循现有的 new + init 异步初始化模式
- 遵循项目的导入语句规范和代码风格

## 目标 / 非目标

### 目标
- 实现主面板的横向和纵向拆分功能
- 支持任意深度的嵌套拆分
- 创建标题栏组件，提供直观的拆分控制界面
- 新拆分的面板继承当前激活面板的路径
- 保持与现有 Resizable 组件的兼容性

### 非目标
- 不实现面板的拖拽重新排列（留待后续版本）
- 不实现面板的关闭功能（本次只关注拆分创建）
- 不实现面板大小比例的持久化存储（留待后续版本）
- 不实现标签页功能（这是另一个独立功能）
- 不实现面板最大化/最小化功能

## 决策

### 决策 1：面板树结构

**选择**：使用递归枚举结构表示面板树

```rust
pub enum PanelNode {
    // 叶子节点：包含实际的文件浏览器实例
    Leaf {
        id: PanelId,
        path: String,
        entries: Vec<FileItem>,
        loading: bool,
        error: Option<String>,
    },
    // 分支节点：包含两个子面板和拆分方向
    Split {
        id: PanelId,
        axis: Axis,  // Horizontal 或 Vertical
        first: Box<PanelNode>,
        second: Box<PanelNode>,
        state: Entity<ResizableState>,  // 复用现有的 Resizable 状态
    },
}
```

**理由**：
- 递归结构天然支持任意深度的嵌套拆分
- 清晰区分叶子面板（显示文件）和分支节点（控制布局）
- 可以复用现有的 Resizable 组件进行大小调整
- 便于实现面板的查找、更新和遍历操作

**考虑的替代方案**：
1. 扁平化面板列表 + 布局配置：更复杂，难以表达嵌套关系
2. 使用第三方布局库：违反项目约束（必须自行实现）

### 决策 2：标题栏组件设计

**选择**：创建独立的 TitleBar 组件，包含拆分按钮和路径显示

```rust
pub struct TitleBar {
    panel_id: PanelId,
    current_path: String,
    on_split_horizontal: Option<Rc<dyn Fn(&mut Window, &mut App)>>,
    on_split_vertical: Option<Rc<dyn Fn(&mut Window, &mut App)>>,
}
```

**理由**：
- 每个面板有独立的标题栏，提供清晰的视觉边界
- 拆分按钮直接关联到对应的面板
- 可以显示当前面板的路径，便于用户识别
- 使用回调函数将拆分逻辑委托给父组件（Explorer）

**考虑的替代方案**：
1. 全局标题栏：无法明确拆分操作针对哪个面板
2. 参考项目的全局 AppTitleBar：不适合多面板场景，每个面板需要独立控制

### 决策 3：激活面板追踪

**选择**：在 Explorer 中添加 `active_panel_id: Option<PanelId>` 字段

**理由**：
- 需要知道用户当前关注哪个面板，以便：
  - 新拆分面板继承当前激活面板的路径
  - 为拆分按钮提供上下文（在哪个面板上执行拆分）
- 为将来的功能（如面板高亮、快捷键操作）提供基础

**实现细节**：
- 用户点击面板内的任何区域时，更新 `active_panel_id`
- 如果 `active_panel_id` 为 None，使用根面板或用户主目录

### 决策 4：拆分操作实现

**选择**：通过递归查找和替换实现面板拆分

```rust
impl PanelNode {
    // 查找指定 ID 的叶子节点，并将其替换为 Split 节点
    pub fn split_panel(
        &mut self,
        panel_id: PanelId,
        axis: Axis,
        new_panel_path: String,
        cx: &mut App
    ) -> bool {
        match self {
            PanelNode::Leaf { id, path, .. } if *id == panel_id => {
                // 将当前叶子节点转换为 Split 节点
                // 原叶子成为 first，新叶子成为 second
                true
            }
            PanelNode::Split { first, second, .. } => {
                // 递归查找子节点
                first.split_panel(panel_id, axis, new_panel_path.clone(), cx) ||
                second.split_panel(panel_id, axis, new_panel_path, cx)
            }
            _ => false,
        }
    }
}
```

**理由**：
- 保持不可变性和所有权语义清晰
- 递归实现简洁，易于理解和维护
- 返回布尔值指示是否成功找到并拆分了面板

### 决策 5：图标集成

**选择**：在 IconName 枚举中添加两个新变体

```rust
pub enum IconName {
    // ... 现有图标
    ColumnsSplit,  // 对应 columns-split.svg
    RowsSplit,     // 对应 rows-split.svg
}
```

**理由**：
- 与现有图标系统保持一致
- 图标文件已经存在于 `crates/explorer-component/assets/icons/` 目录
- 遵循现有的图标命名约定

### 决策 6：Resizable 组件复用

**选择**：直接复用现有的 Resizable 组件，无需修改

**理由**：
- 现有 Resizable 已经支持横向和纵向拆分（通过 axis 参数）
- 已经实现了拖拽调整大小的完整逻辑
- 状态管理机制可以直接用于面板树的每个分支节点
- 避免重复实现和潜在的不一致性

## 风险 / 权衡

### 风险 1：深度嵌套的性能问题
- **风险**：多层嵌套拆分可能导致递归渲染性能下降
- **缓解**：
  - GPUI 框架有内置的增量渲染优化
  - 实际使用中，用户不太可能创建超过 4-5 层的嵌套
  - 如果成为问题，可以在将来添加最大深度限制

### 风险 2：状态管理复杂性
- **风险**：面板树结构增加了状态更新的复杂性
- **缓解**：
  - 清晰定义面板 ID 生成策略（递增计数器）
  - 提供辅助函数简化常见操作（查找、更新、遍历）
  - 保持单一数据源原则，避免状态分散

### 风险 3：用户体验混淆
- **风险**：用户可能不清楚拆分按钮的作用对象
- **缓解**：
  - 每个面板有明确的视觉边界（标题栏、边框）
  - 激活面板有视觉反馈（如高亮边框）
  - 拆分按钮位于面板标题栏内，明确关联关系

## 迁移计划

### 阶段 1：数据结构和基础组件
1. 定义 PanelNode 枚举和相关类型
2. 实现 PanelId 生成器
3. 创建 TitleBar 组件
4. 在 IconName 中添加新图标

### 阶段 2：核心拆分逻辑
1. 实现 PanelNode 的拆分方法
2. 实现面板查找和更新辅助函数
3. 在 Explorer 中集成面板树管理

### 阶段 3：UI 集成和交互
1. 实现面板树的递归渲染
2. 连接标题栏按钮到拆分逻辑
3. 实现激活面板追踪
4. 确保新面板继承正确的路径

### 阶段 4：测试和优化
1. 测试各种拆分场景（横向、纵向、嵌套）
2. 测试边界情况（单面板、深度嵌套）
3. 性能测试和优化
4. 用户体验测试和调整

### 回滚策略
- 保持现有的单面板渲染逻辑作为后备
- 如果发现严重问题，可以通过特性开关禁用拆分功能
- 数据结构设计确保可以轻松转换回单面板模式

## 待解决问题

1. **面板关闭功能**：本次变更不包含关闭面板功能，但应考虑将来如何实现（从树中移除节点、合并父节点等）

2. **面板大小持久化**：用户调整的面板大小比例是否需要保存？如果需要，应如何序列化面板树结构？

3. **初始布局**：应用启动时应该显示单面板还是默认的拆分布局？（建议：单面板，简单明了）

4. **最大面板数限制**：是否需要限制最大面板数量以避免性能问题？（建议：暂时不限制，观察实际使用情况）

5. **键盘快捷键**：是否应该提供键盘快捷键进行拆分操作？（建议：留待后续版本，先确保鼠标操作流畅）
